import numpy as np
import matplotlib.pyplot as plt
from matplotlib import ticker
import mpl_toolkits.mplot3d

formatter = ticker.ScalarFormatter(useMathText=True)
formatter.set_scientific(True)
formatter.set_powerlimits((-1,1))

def plot3d(t=[],v=[],title=1,l = [0,162,0,162],x='x',y='y',z='z'):
	ax=plt.subplot(111,projection='3d')
	ax.scatter(t[0],t[1],t[2],marker='*',color='r')
	ax.scatter(v[0],v[1],v[2],marker='.',color='b')
	ax.set_xlabel(r(x),size=18.0)
	ax.set_ylabel(r(y),size=18.0)
	ax.set_zlabel(r(z),size=18.0)
	if title==1:
		ax.set_title('Distribution of tracers and voids in Lambda')
	else:
		ax.set_title('Distribution of tracers and voids in R-P')
	ax.axis(l)
	

def read(s = 'L', i = 0, n = 8, d = 2):
	l1 = np.array([retxt('NF_'+s+'_'+str(x+1)+'.txt', d)[i] for x in range(n)])
	l2 = np.array([np.cumsum(l) for l in l1])
	return [l1,l2]

def r(s=r'R_{V}'):
	return r'$' + s + r'[\mathrm{Mpc}\cdot h^{-1}]$'

def n1(b = 1):
	b = str(b)
	return r'$N_{V}\left(bin='+b+r'\ \mathrm{Mpc}\cdot h^{-1}\right)$'

def n2():
	return r'$N_{V}\left(R_{V}\leq R\right)$'

def nd(l, V = 1296.0**3):
	n = len(l[0])
	ly = []
	lx = []
	for i in range(n-2):
		a = l[1][i+3]-l[1][i+1]/(l[0][i+3]-l[0][i+1])
		b = l[0][i+2]*a
		ly.append(b/V)
		lx.append(l[0][i+2])
	return [lx, ly]

def std(l):
	m = len(l)
	n = len(l[0])
	average = []
	for i in range(n):
		s = 0
		for j in range(m):
			s += l[j][i]
		average.append(s/float(m))
	std = []
	for i in range(n):
		s = 0
		for j in range(m):
			s += (l[j][i]-average[i])**2
		std.append((s/(m))**0.5)
	lu, ll, lSN = [], [], []
	for i in range(n):
		lu.append(average[i]+std[i])
		ll.append(average[i]-std[i])
		print (ll[i])
		if std[i]!=0:
			lSN.append(abs(average[i]/std[i]))
		else:
			lSN.append(0.0)
	Aa = np.add.accumulate(average)
	Aup = np.add.accumulate(lu)
	Alow = np.add.accumulate(ll)
	d = {}
	d['a'], d['up'], d['low'], d['e'], d['std'], d['SN'], d['l'] = average, lu, ll, std, sum(std)/n, lSN, [average, ll, lu, Aa, Alow, Aup, std, lSN]
	return d

def ratio(lr, l1, l2):
	m, n = len(l), len(l2)
	out = [[], []]
	if n>m:
		a, b = n, m
	else:
		a, b = m, n
	for i in range(b):
		if (l2[i]!=0) and (l1[i]!=0):
			out[1].append(l1[i]/l2[i])
			out[0].append(lr[i])
	return out

def extract(l1, l2):
	la1, ll1, lu1, la2, ll2, lu2 = l1[0], l1[1], l1[2], l2[0], l2[1], l2[2]
	m, n = len(la1), len(la2)
	out = [[], [], []]
	if n>m:
		a, b = n, m
	else:
		a, b = m, n	
	for i in range(b):
		out[0].append(la1[i]-la2[i])
		out[1].append(ll1[i]-lu2[i])
		out[2].append(lu1[i]-ll2[i])
	return out


def stdio():
	return ['radius', 'aver', 'low', 'up', 'A_aver', 'A_low', 'A_up', 'std', 'S/N']
	
def retxt(s, n, k = 1, t = 1):
	out = []
	for i in range(n):
		out.append([])
	j = 0
	with open(s, 'r') as f:
		for line in f:
			lst = line.split()
			if j<k:
				print (lst[0])
			else:
				for i in range(n):
					out[i].append(float(lst[i]))
			j = j+1
	if t!=0:
		for i in range(n):
			out[i].reverse()
			out[i] = np.array(out[i])
	return np.array(out)

def totxt(s, l, ls = stdio(), t = 0, k = 0):
	j = 0
	with open(s, 'w') as f:
		if t!=0:
			for r in range(len(ls)):
				f.write(ls[r])
				f.write(' ')
			f.write('\n')
		for i in range(len(l[0])):
			if j<k:
				print (l[0][i])
			else:
				for s in range(len(l)):
					f.write(str(l[s][i]))
					f.write(' ')
				f.write('\n')
			j = j+1

def f1(x):
	return x-1296.0

def modify(l, lm, f = f1):
	out = []
	for k in range(len(l)):
		out.append([])
	for i in range(len(l[0])):
		for j in range(len(l)):
			if lm[j]==1:
				out[j].append(f(l[j][i]))
			else:
				out[j].append(l[j][i])
	return out
